<<<<<<< Upstream, based on origin/0.6.0.M47
package net.sf.jkniv.whinstone.jdbc.commands;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Date;
import java.util.Map;

import net.sf.jkniv.exception.HandleableException;
import net.sf.jkniv.reflect.beans.MethodName;
import net.sf.jkniv.reflect.beans.MethodNameFactory;
import net.sf.jkniv.reflect.beans.ObjectProxy;
import net.sf.jkniv.reflect.beans.ObjectProxyFactory;
import net.sf.jkniv.sqlegance.Insertable;
import net.sf.jkniv.whinstone.Queryable;

class SettingSequenceGeneratedKey
{
    private static final MethodName   SETTER = MethodNameFactory.getInstanceSetter();
    private final HandleableException handlerException;
    private Queryable                 queryable;
    private Insertable                 isql;
    private Connection                conn;
    
    public SettingSequenceGeneratedKey(Queryable queryable, Insertable isql, Connection conn,
            HandleableException handlerException)
    {
        this.queryable = queryable;
        this.isql = isql;
        this.conn = conn;
        this.handlerException = handlerException;
    }
    
    public void set()
    {
        Number nextValue = null;
        String[] properties = isql.getAutoGeneratedKey().getPropertiesAsArray();
        
        if (properties.length != 1) // TODO test me
            handlerException.throwMessage(
                    "<autoGeneratedKey> with SEQUENCIAL strategy just accept only one properties there are [%i]",
                    properties.length);
        
        if (this.queryable.isTypeOfArray() || this.queryable.isTypeOfCollection())
            handlerException.throwMessage(
                    "Cannot set auto generated key for collections or array instance of parameters at query [%s]",
                    queryable.getName());
        
        try
        {
            String sql = isql.getAutoGeneratedKey().getText();
            PreparedStatement stmt = conn.prepareStatement(sql);            
            ResultSet sequenceRs = stmt.executeQuery();
            
            if (sequenceRs.next())
                nextValue = sequenceRs.getLong(1);

=======
/* 
 * JKNIV, whinstone one contract to access your database.
 * 
 * Copyright (C) 2017, the original author or authors.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software Foundation, Inc., 
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.sf.jkniv.whinstone.jdbc.commands;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Date;
import java.util.Map;

import net.sf.jkniv.exception.HandleableException;
import net.sf.jkniv.reflect.beans.MethodName;
import net.sf.jkniv.reflect.beans.MethodNameFactory;
import net.sf.jkniv.reflect.beans.ObjectProxy;
import net.sf.jkniv.reflect.beans.ObjectProxyFactory;
import net.sf.jkniv.sqlegance.Insertable;
import net.sf.jkniv.whinstone.Queryable;

/**
 * Call an database sequence and put the value into parameter object from {@link Queryable}
 * 
 * @author Alisson Gomes
 * @since 0.6.0
 */
class SettingSequenceGeneratedKey
{
    private static final MethodName   SETTER = MethodNameFactory.getInstanceSetter();
    private final HandleableException handlerException;
    private Queryable                 queryable;
    private Insertable                isql;
    private Connection                conn;
    
    public SettingSequenceGeneratedKey(Queryable queryable, Insertable isql, Connection conn,
            HandleableException handlerException)
    {
        this.queryable = queryable;
        this.isql = isql;
        this.conn = conn;
        this.handlerException = handlerException;
    }
    
    public void set()
    {
        Number nextValue = null;
        String[] properties = isql.getAutoGeneratedKey().getPropertiesAsArray();
        
        if (properties.length != 1) // TODO test me
            handlerException.throwMessage(
                    "<autoGeneratedKey> with SEQUENCIAL strategy just accept only one properties there are [%i]",
                    properties.length);
        
        if (this.queryable.isTypeOfArray() || this.queryable.isTypeOfCollection())
            handlerException.throwMessage(
                    "Cannot set auto generated key for collections or array instance of parameters at query [%s]",
                    queryable.getName());
        
        try
        {
            String sql = isql.getAutoGeneratedKey().getText();
            PreparedStatement stmt = conn.prepareStatement(sql);
            ResultSet sequenceRs = stmt.executeQuery();
            
            if (sequenceRs.next())
                nextValue = sequenceRs.getLong(1);
            
>>>>>>> 3a27083 whinstone-jdbc move code REMOVE to work with Command and CommandHandler
            if (this.queryable.isTypeOfMap())
            {
                Map<String, Object> instance = (Map) queryable.getParams();
                instance.put(properties[0], nextValue);
            }
            else
            {
                ObjectProxy<?> proxy = ObjectProxyFactory.newProxy(queryable.getParams());
                setValue(proxy, properties[0], nextValue);
            }
        }
        catch (SQLException sqle)
        {
            handlerException.handle(sqle);
        }
    }
    
    private void setValue(ObjectProxy<?> proxy, String property, Object value)
    {
        Object parsedValue = value;
        
        if (value instanceof java.sql.Time)
            parsedValue = new Date(((java.sql.Time) value).getTime());
        else if (value instanceof java.sql.Date)
            parsedValue = new Date(((java.sql.Date) value).getTime());
        else if (value instanceof java.sql.Timestamp)
            parsedValue = new Date(((java.sql.Timestamp) value).getTime());
        
        proxy.invoke(SETTER.capitalize(property), parsedValue);
    }
    
}
