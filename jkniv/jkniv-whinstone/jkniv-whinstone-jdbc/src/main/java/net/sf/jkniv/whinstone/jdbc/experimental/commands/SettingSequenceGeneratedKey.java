package net.sf.jkniv.whinstone.jdbc.experimental.commands;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Date;
import java.util.Map;

import net.sf.jkniv.exception.HandleableException;
import net.sf.jkniv.reflect.beans.MethodName;
import net.sf.jkniv.reflect.beans.MethodNameFactory;
import net.sf.jkniv.reflect.beans.ObjectProxy;
import net.sf.jkniv.reflect.beans.ObjectProxyFactory;
import net.sf.jkniv.sqlegance.Insertable;
import net.sf.jkniv.sqlegance.Queryable;

class SettingSequenceGeneratedKey
{
    private static final MethodName   SETTER = MethodNameFactory.getInstanceSetter();
    private final HandleableException handlerException;
    private Queryable                 queryable;
    private Insertable                 isql;
    private Connection                conn;
    
    public SettingSequenceGeneratedKey(Queryable queryable, Insertable isql, Connection conn,
            HandleableException handlerException)
    {
        this.queryable = queryable;
        this.isql = isql;
        this.conn = conn;
        this.handlerException = handlerException;
    }
    
    public void set()
    {
        Number nextValue = null;
        String[] properties = isql.getAutoGeneratedKeyTag().getPropertiesAsArray();
        
        if (properties.length != 1) // TODO test me
            handlerException.throwMessage(
                    "<autoGeneratedKey> with SEQUENCIAL strategy just accept only one properties there are [%i]",
                    properties.length);
        
        if (this.queryable.isTypeOfArray() || this.queryable.isTypeOfCollection())
            handlerException.throwMessage(
                    "Cannot set auto generated key for collections or array instance of parameters at query [%s]",
                    queryable.getName());
        
        try
        {
            String sql = isql.getAutoGeneratedKeyTag().getText();
            PreparedStatement stmt = conn.prepareStatement(sql);            
            ResultSet sequenceRs = stmt.executeQuery();
            
            if (sequenceRs.next())
                nextValue = sequenceRs.getLong(1);

            if (this.queryable.isTypeOfMap())
            {
                Map<String, Object> instance = (Map) queryable.getParams();
                instance.put(properties[0], nextValue);
            }
            else
            {
                ObjectProxy<?> proxy = ObjectProxyFactory.newProxy(queryable.getParams());
                setValue(proxy, properties[0], nextValue);
            }
        }
        catch (SQLException sqle)
        {
            handlerException.handle(sqle);
        }
    }
    
    private void setValue(ObjectProxy<?> proxy, String property, Object value)
    {
        Object parsedValue = value;
        
        if (value instanceof java.sql.Time)
            parsedValue = new Date(((java.sql.Time) value).getTime());
        else if (value instanceof java.sql.Date)
            parsedValue = new Date(((java.sql.Date) value).getTime());
        else if (value instanceof java.sql.Timestamp)
            parsedValue = new Date(((java.sql.Timestamp) value).getTime());
        
        proxy.invoke(SETTER.capitalize(property), parsedValue);
    }
    
}
